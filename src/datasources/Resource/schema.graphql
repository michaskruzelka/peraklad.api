type Query {
    fileFormats(
        category: ProjectCategory!
        subCategory: ProjectSubCategory
    ): [FileFormat!]!
    ResourceItem(id: ID!): ResourceItem
    resourceItemStatuses: [ResourceItemStatus]!
}

type FileFormat {
    code: String!
    name: String!
    extensions: [String!]!
    longName: String
    description: String
}

type ResourceStatus {
    id: Int!
    code: String!
}

type ResourceItemStatus {
    id: Int!
    code: String!
}

type TranslationType {
    id: Int!
    code: String!
}

type TranslationService {
    id: Int!
    code: String!
    name: String!
}

type TranslationStatus {
    id: Int!
    code: String!
}

type Translation {
    id: ID!
    text: String!
    status: TranslationStatus! @cypher(statement: "RETURN { id: this.status }")
    type: TranslationType! @cypher(statement: "RETURN { id: this.type }")
    service: TranslationService
        @cypher(statement: "RETURN { id: this.service }")
    resourceItem: ResourceItem @relation(name: "FOR", direction: OUT)
}

type Duration {
    hours: Int!
    minutes: Int!
    seconds: Int!
    milliseconds: Int!
    total: Int!
    formatted: String!
}

type TimingFormat {
    fileFormat: FileFormat!
    text: String!
}

type Timing {
    startsAt: Duration!
        @cypher(
            statement: """
            RETURN {
                hours: this.startsAt.hours,
                minutes: this.startsAt.minutesOfHour,
                seconds: this.startsAt.secondsOfMinute,
                milliseconds: this.startsAt.millisecondsOfSecond,
                total: this.startsAt.milliseconds,
                formatted: toString(this.startsAt)
            }
            """
        )
    endsAt: Duration!
        @cypher(
            statement: """
            RETURN {
                hours: this.endsAt.hours,
                minutes: this.endsAt.minutesOfHour,
                seconds: this.endsAt.secondsOfMinute,
                milliseconds: this.endsAt.millisecondsOfSecond,
                total: this.endsAt.milliseconds,
                formatted: toString(this.endsAt)
            }
            """
        )
    difference: Duration!
        @cypher(
            statement: """
            WITH duration({
                milliseconds: this.endsAt.milliseconds - this.startsAt.milliseconds
            }) AS diff
            RETURN {
                hours: diff.hours,
                minutes: diff.minutesOfHour,
                seconds: diff.secondsOfMinute,
                milliseconds: diff.millisecondsOfSecond,
                total: diff.milliseconds,
                formatted: toString(diff)
            }
            """
        )
    # get start and ends and traverse to resourceItemContext and get labels to determine the category
    # and thus to get a list of specific formats (srt, sbv, etc.).
    # If not traversable, ignore, return null.
    # formatted: [TimingFormat!] @cypher(statement: """
    # """)
}

type Recommendation {
    language: Language! @cypher(statement: "RETURN { code: this.language }")
    text: String!
    createdAt: DateTime!
    timing: Timing @relation(name: "HAS_TIMING", direction: OUT)
}

type SRT {
    coordinates: String
}

type VTT {
    cueSettings: String
}

# add XLIFF and others

union Format = SRT | VTT

interface ResourceItemContext {
    formats: [Format] @relation(name: "SPECIFIC_FOR", direction: OUT)
}

type Subtitle implements ResourceItemContext {
    formats: [Format] @relation(name: "SPECIFIC_FOR", direction: OUT)
    timing: Timing! @relation(name: "HAS_TIMING", direction: OUT)
}

type SoftwareElement implements ResourceItemContext {
    formats: [Format] @relation(name: "SPECIFIC_FOR", direction: OUT)
    key: String
}

type Comment {
    id: ID!
    text: String!
    resourceItem: ResourceItem @relation(name: "IN", direction: OUT)
}

input ResourceItemFilter {
    status: [Int!]
    text: String
}

type ResourceItem {
    id: ID!
    text: String!
    status: ResourceItemStatus! @cypher(statement: "RETURN { id: this.status }")
    nextItem: ResourceItem @relation(name: "NEXT", direction: OUT)
    prevItem: ResourceItem @relation(name: "NEXT", direction: IN)
    nextItems(limit: Int! = 50 @range(min: 1, max: 100)): [ResourceItem]
        @cypher(
            statement: """
            MATCH (this)-[:NEXT*1..100]->(ni:ResourceItem)
            RETURN ni LIMIT toInteger($limit)
            """
        )
    prevItems(limit: Int! = 50 @range(min: 1, max: 100)): [ResourceItem]
        @cypher(
            statement: """
            MATCH (this)<-[:NEXT*1..100]-(pi:ResourceItem)
            RETURN pi LIMIT toInteger($limit)
            """
        )
    translation: [Translation] @relation(name: "FOR", direction: IN)
    context: ResourceItemContext! @relation(name: "HAS_CONTEXT", direction: OUT)
    comment: [Comment] @relation(name: "IN", direction: IN)
    recommendation: [Recommendation] @relation(name: "FOR", direction: IN)
    similar: [ResourceItem]
}

type Resource {
    id: ID!
    name: String!
    language: Language! @cypher(statement: "RETURN { code: this.language }")
    status: ResourceStatus! @cypher(statement: "RETURN { id: this.status }")
    project: Project!
        @cypher(statement: "MATCH (this)<-[:TRANSLATING]-(p:Project) RETURN p")
    format: FileFormat!
        @cypher(
            statement: """
            MATCH (this)<-[:TRANSLATING]-(p:Project)
            RETURN { code: { _code: this.format, _labels: labels(p) } }
            """
        )
    firstItem: ResourceItem @relation(name: "FIRST_ITEM", direction: OUT)
    lastItem: ResourceItem @relation(name: "LAST_ITEM", direction: OUT)
    foundItem(filter: ResourceItemFilter): ResourceItem
        @cypher(
            statement: """
            MATCH (this)-[:FIRST_ITEM]->(:ResourceItem)-[:NEXT*0..]->(ri:ResourceItem)
            RETURN ri LIMIT 1
            """
        )
}
